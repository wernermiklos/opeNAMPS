\documentclass[aps,prb,twocolumn,showpacs,preprintnumbers,amsmath,amssymb, superscriptaddressm, nofootinbib]{revtex4-2}   % version 4-2 is the newest
\usepackage[utf8]{inputenc}
\usepackage{amsmath}    % need for subequations
\usepackage{amssymb}
\usepackage{graphicx}   % need for figures
\usepackage{color}
\usepackage{xcolor}      % use if color is used in text
%\usepackage{subfigure}  % use for side-by-side figures
\usepackage{hyperref}   % use for hypertext links, including those to external documents and URLs
%\usepackage{blindtext}
\usepackage[normalem]{ulem}
\usepackage{bm}
%\usepackage{natbib}
%\usepackage{fixmath}
%\usepackage{dsfont}
\hypersetup{colorlinks,linkcolor=blue,urlcolor=blue,citecolor=blue}

\newcommand{\sym}{\mathrm{sym}}
\newcommand{\leg}{\mathrm{leg}}
\newcommand{\rep}{\mathrm{rep}}
\newcommand{\loc}{\mathrm{loc}}
\newcommand{\dep}{\mathrm{dep}}

\begin{document}
\title{Short introduction to \textbf{opeNAMPS} -- an open, lightweight non-Abelian MPS software package}

\author{Miklós Antal Werner}
\affiliation{Department of Theoretical Physics, Institute of Physics, Budapest University of Technology and Economics, Műegyetem rkp. 3., H-1111 Budapest, Hungary}
\affiliation{MTA-BME Quantum Dynamics and Correlations Research Group, Budapest University of Technology and Economics, Műegyetem rkp. 3., H-1111 Budapest, Hungary}
\affiliation{Strongly Correlated Systems 'Lend\" ulet' Research Group, Wigner Research Centre for Physics, P.O. Box 49, 1525 Budapest, Hungary}
\date{August 30, 2023}
 
\begin{abstract}
 The opeNAMPS software package is introduced and the main functionalities are described. MatLab R2022b or newer is required to run opeNAMPS. 

\end{abstract}
\maketitle

\section{About opeNAMPS}
In this document we introduce the opeNAMPS software, that is free software under the GNU General Public License (GPLv3 \cite{GPLv3}). You are free to use and improve the software, but we kindly ask you to cite Ref.~\onlinecite{NATEBD_paper}, where the theoretical foundations of opeNAMPS are described in details.  

\textbf{The current version of opeNAMPS contains} 
\begin{itemize}
    \item a general tensor class "NAtensor" that can be used both for Abelian and non-Abelian symmetries
    \item MPS structures for both Abelian and non-Abelian symmetries
    \item Time Evolving Block Decimation (TEBD) algorithm for both Abelian and non-Abelian symmetries
    \item Structures that can store symmetries, sites for specific models.
    \item Commonly used models like Heisenberg spin chains and the Hubbard model is also implemented.
    \item Example run scripts for both Abelian and non-Abelian models
\end{itemize}
\textbf{Important note:} Before running the scripts it is necessary to execute the \verb|pathimport.m| script from the root folder of opeNAMPS.

\section{opeNAMPS basics}
Below we describe the basic constituents of the code. See also Ref.~\onlinecite{NATEBD_paper,MikiPhD} for a more detailed introduction. 

\subsection{Quantum numbers and irrep indices}
States of a quantum system with $N_\sym$ symmetries are usually characterized by $N_\sym$ different quantum numbers. For example, a states of a system with an $SU(2)$ spin and $U(1)$ charge symmetry are characterized by numbers $\lbrace S, Q \rbrace$, where $S$ is the total spin and $Q$ is the total charge of the state $\left| \lbrace S,Q \rbrace; \psi \right\rangle$. From a group theoretical perspective, $S$ marks an irreducible representation of the $SU(2)$ group while $Q$ marks an irrep of the $U(1)$ group. 

In the opeNAMPS code, instead of using the physical quantum numbers like $S$ and $Q$, representations of simple groups are always indexed by positive integer numbers $\gamma \in \lbrace 1,2,3,\dots \rbrace$. For more then one symmetry, the collection $\Gamma = \left[ \gamma_1, \gamma_2, \dots, \gamma_{N_\sym} \right]$ of these indices stands for the total irrep index that characterizes the state. In the following, we simply refer to $\Gamma$ as the irrep index of the state, which index contains $N_\sym$ positive integers. Trivial representation is always $\Gamma = [1,1,\dots,1]$.

\smallskip
\textbf{Indexing conventions $SU(2)$, $U(1)$, and $\mathbb{Z}_2$ groups} \\
While users are free to define their symmetries using any convention (except that the trivial representation must be $\gamma = 1$), below we show the convention used in the predefined symmetry classes.
\begin{itemize}
\item For the $SU(2)$ we simply use $\gamma_{SU(2)} = 2S + 1$.
\item In case of $U(1)$ the representation index corresponding to the (integer, but possibly negative) charge $Q$ is the position index of $Q$ in the following series: $\lbrace 0, -1, +1, -2, +2, -3, +3, \dots \rbrace$, i.e.
\begin{equation}
   \gamma_{U(1)} = 2 |Q| + \mathbf{1}_{Q \ge 0}(Q) \;,  
\end{equation}
where the indicator function $\mathbf{1}_{Q \ge 0}(Q)$ is $1$ if $Q \ge 0$ and zero otherwise.
\item In the case of $\mathbb{Z}_2$ parity symmetry $\gamma = 1$ stands for the even (+), and $\gamma=2$ for the odd (-) states.
\end{itemize}

\subsection{NA-tensors}
NA-tensors are the basic building blocks in the opeNAMPS code. They are block-sparse tensors with a particular block structure that follows from the symmetry related quantum numbers which belong to the indices (or legs) of the NA-tensor. The data structure of NA-tensors is the following: 
\begin{itemize}
    \item NAtensors have $N_\leg$ legs. We refer to the legs by their names (strings) that are stored in the \verb|NAtensor.leg_names| cell array.
    \item Legs have type (\verb|NAtensor.leg_types|), that can be incoming (\verb|'i'|) and outgoing (\verb|'o'|). Contracion rules are simple: incoming legs can be contracted only with outgoing ones.
    \item Blocks of the tensor are indexed by a list of irrep indices, $[\Gamma_1, \Gamma_2, \dots, \Gamma_{N_\rep}]$, that we may call as the "key" of the block and which key contains a total of $N_\sym \cdot N_\rep$ positive integer numbers. 
    \item The data blocks ($N_\leg$-dimensional arrays) are stored in \verb|NAtensor.data| variable, that is a \verb|containers.Map()| associative container (data is stored in \verb|key| $\rightarrow$ \verb|block| pairs). The key of a block is just $[\Gamma_1, \Gamma_2, \dots, \Gamma_{N_\rep}]$ casted to \verb|char| data type.
    \item Legs of the NAtensor depend on one or more irrep indices from the "key". The \verb|NAtensor.dependencies| cell array contains the dependencies for each leg. For example, if dependencies of some leg are $[d_1, d_2, \dots, d_m]$ that means that the leg depends on $[\Gamma_{d_1}, \Gamma_{d_2}, \dots, \Gamma_{d_m}]$ irrep indices from the key. The order of dependencies is important. The different $[\Gamma_{d_1}, \Gamma_{d_2}, \dots, \Gamma_{d_m}]$ lists characterize \emph{sectors} of the leg. 
    \item If we contract two tensors, the dependecies of the contracted legs are matched, i.e. only those blocks of the two tensors are contraced, where the  $[\Gamma_{d_1}, \Gamma_{d_2}, \dots, \Gamma_{d_m}]$ indices are the same. See also Refs.~\onlinecite{NATEBD_paper,MikiPhD} for more details. 
\end{itemize}

\textbf{Examples of NA-tensors} \\
A simple example is the usual MPS tensor $A_{m\,\sigma}^{m'}$ that rotates from the product basis $|m\rangle \otimes |\sigma \rangle$ to the Schmidt-basis $|m'\rangle$,
\begin{equation}
    |m'\rangle = \sum_{m,\sigma} A_{m\,\sigma}^{m'} |m\rangle \otimes |\sigma \rangle
\end{equation}
If we have symmetries, and the irrep indices of states $m$, $\sigma$, and $m'$ are $\Gamma$, $\Gamma^\loc$, $\Gamma'$, respectively, then the MPS tensor can be written as an NA-tensor, $A(\lbrace \Gamma, \Gamma^\loc, \Gamma' \rbrace)_{m\sigma}^{m'}$, where the dependencies of the legs are $\dep(m) = [1]$, $\dep(\sigma) = [2]$, $\dep(m') = [3]$, i.e leg $m$ depends on the first, leg $\sigma$ on the second, and leg $m'$ on the third irrep index.

An other, more interesting example is the Clebsch-Gordan tensor, that is built from the generalazied Clebsch-Gordan coefficients, 
\begin{equation}
    \left(\Gamma_1, m_1; \Gamma_2, m_2 | \Gamma, M \right)_\alpha \;. 
\end{equation}
These amplitudes are used, when we search for irreducible representations in the product of two irreps $\Gamma_1$ and $\Gamma_2$. Here $\Gamma$ is the outgoing irrep index, and $\alpha$ is the so called outer multiplicity that enumerates the multiplets in the $\Gamma_1 \times \Gamma_2$ product having the same $\Gamma$ irrep index. These Clebsch-Gordan coefficients can be stored in the NA-tensor $C(\lbrace \Gamma_1, \Gamma_2, \Gamma \rbrace)_{m_1 m_2}^{M \alpha}$ in which $\dep(m_1) = [1]$, $\dep(m_2) = [2]$, $\dep(M) = [3]$, while the outer multiplicity index has a triple dependency $\dep(\alpha) = [1,2,3]$.

The main purpose of this document is the description of the code, the construction of NA-tensors and their algebraic properties are described in more details in Refs.~\onlinecite{NATEBD_paper,MikiPhD}.

\textbf{Handling NA-tensors in opeNAMPS} \\
In this short paragraph basic code examples are shown in which we define an NA-tensor, we set some blocks of it, we perform simple algebraic transformations, and contractions. The full script is in the file \verb|run_scripts/NAtensor_demo.m|, in the example the number of symmetries is \verb|NO_OF_SYMS = 2;|.

Our tensor will have a dependency structure similar to the Clebsch-Gordan tensor:
\begin{eqnarray}
    T(\lbrace \Gamma_1, \Gamma_2, \Gamma_3 \rbrace)_{a~b}^{c~\eta} \nonumber \\
    \dep(a) = [1], &~& \dep(b) = [2], \nonumber \\ 
    \dep(c) = [3], &~& \dep(\eta) = [1,2,3]
\end{eqnarray}
The tensor has two incoming legs (\verb|'a'| and \verb|'b'|), and two outgoing legs (\verb|'c'| and \verb|'eta'|), its possible definition in the code reads as
\begin{verbatim}
T = NAtensor({'a','b','c','eta'}, ... 
             {'i','i','o','o'}, ... 
             {[1],[2],[3],[1,2,3]}, ... 
             NO_OF_SYMS);
\end{verbatim}
Here the first argument is the cell array of the leg names, the second cell array contains the leg types, the third one contains the dependencies, and the fourth is just the number of symmetries. It is important, that in the dependencies $\Gamma$ labels are enumerated starting from $1$ to $m$, with no missing numbers. ($m$ is $3$ in our case): it is mandatory to index irrep labels this way.

\verb|T| is now an empty NAtensor, with no active (nonzero) blocks. We can set blocks with the \verb|NTset_block| function:
\begin{verbatim}
T = NTset_block(T, ...
            {{'a',1},{'b',1}, {'c',1}}, ...
            {[2,3] ,[3,4], [4,5]}, ...
            {'a','b','c','eta'}, ...
            ones(4,6,8,2));
\end{verbatim}
Here, the first argument is the NAtensor itself\footnote{In the opeNAMPS we avoid to use classes because class function calls have a rather large overhead in MatLab.}, the second argument specifies the irrep positions (irrep is specified by a [legname - which dependency of the leg] pairs), in the third argument we give the values of irrep indices ($\Gamma$ quantum numbers), in the fourth argument we specify the order of the legs in which the tensorblock array (fifth argument, in the example a 4-order tensor filled with ones) is passed. 

In the second argument it is obligatory to mark all the irrep labels once. However, the order, and the way how we refer to the irrep labels is irrelevant. The following code is equivalent with the one above,
\begin{verbatim}
T = NTset_block(T, ...
            {{'b',1},{'eta',3}, {'eta',1}}, ...
            {[3,4] ,[4,5], [2,3]}, ...
            {'eta','b','a','c'}, ...
            ones(2,6,4,8)); 
\end{verbatim}
We note that the user has a large freedom in the order in which the irreps are specified (2nd and 3rd argument), and also in the order of legs (4th and 5th argument).It is important to note one issue about the dimensions of legs within blocks: the dimensions of legs must depend only on the $\Gamma$ values of its dependency irrep labels. E.g. in our example the leg \verb|'a'| is 4 dimensional, while its dependency ($\Gamma_1$) contains the quantum numbers $[2,3]$. We may set other blocks in which $\Gamma_1$ is still $[2,3]$, while $\Gamma_2$ and $\Gamma_3$ may differ from the values in the example above: the \verb|'a'| leg must be $4$-dimensional also in these blocks. The code in its present version does not check these dimension consitencies by default.

NAtensor can be multiplied by scalars, can be added to each other, or can be complex conjugated
\begin{verbatim}
    twoT = NTmult(T,2);   %2 * T 
    TplusT = NTadd(T,T);  % T + T
    TminustwoT = NTsubtr(T,twoT);  % T - 2 * T
    minusT = NTneg(T);   % -T
    conjT = NTconj(T);   % T*
\end{verbatim}
We note that complex conjugation reverses the direction of the legs (\verb|'o'| $\leftrightarrow$ \verb|'i'|).

Tensors can also be contracted, i.e. incoming and outgoing legs can be connected to each other, if the sector structure (sector dimensions) of the legs are equivalent. For example the \verb|'a'| leg of \verb|T| and \verb|conjT| can be contracted. However, the result tensor would have two \verb|'b'|, two \verb|'c'| and two \verb|'eta'| legs. To resolve this naming issue, we have to rename the legs of one of the tensors. The first solution uses \verb|NTprime_all_legs|
\begin{verbatim}
    %NTprime_all_legs: adds '~' to leg names
    conjT_primed = NTprime_all_names(conjT);
    TconjT = NTdot(T,conjT_primed, ... 
                   {'a'},{'a~'});
\end{verbatim}
The result is an NAtensor with six legs: \verb|{'b','b~','c','c~','eta','eta~'}|. 

In the second solution we rename the legs by hand prior contraction. This solution is lengthier, but gives more freedom: we can choose arbitrary new names. In the following example we change the uncontracted leg names of \verb|conjT| to \verb|{'d','e','xi'}|
\begin{verbatim}
    conjT_renamed = NTrename_legs(conjT, ... 
           {'b','c','eta'},{'d','e','xi'});
    TconjT = NTdot(T,conjT_renamed, ... 
                   {'a'},{'a'});
\end{verbatim}

There is also a third solution: in \verb|NTdot| we have an optional 5th argument called \verb|renaming|. If we pass this, we can set the new names directly in \verb|NTdot()|.
\vspace{6pt}

\section{Abelian MPS and TEBD}
While the general non-Abelian routings can also be used for Abelian symmetries, there are also simpler Abelian routines prepared that can also be used. In these routines everything looks more or less like in a simple non-symmetric code, and only the simple fusion rules of the corresponding Abelian symmetry group are used.

\subsection{The ABSITE structure}
Necessary information about single Abelian sites are encoded in ABSITE structures. These structures contain basic information about the site, and contain also the local operators (in NAtensor structures) and their basic properties. 
For fermionic sites (modes), the \verb|ABSITE.fermions| field is 1, and in that case the Jordan-Wigner phase operator \verb|ABSITE.operators('ph')| must be defined.
The NAtensor operators are collected in the \verb|ABSITE.operators()| map container, and for fermionic sites the \verb|ABSITE.fermionicities()| container sets the fermionic sign ($\pm 1$) of the operator. The operators are represented by two-leg NAtensors $O_{\tilde{\tau} \tau}$, where the \verb|'tau'| leg will be contracted with the \verb|'tau'| leg of the MPS wavefunction.  

\subsubsection{Example: the U(1) spinless fermion site}
$U(1)$ symmetric femion site can be defined by the \verb|ABSITE_U1_spinless_fermion(U1sym,Q_empty,Q_occ)| function. Here \verb|U1sym| is the $U(1)$ symmetry structure, generated by the \verb|generate_U1_symmetry([],[],[])| function, \verb|Q_empty| is the (integer) charge associated to the empty state, \verb|Q_occ| is the (integer) charge associated to the occupied state. In this case \verb|ABSITE.fermions == 1|, i.e. we have fermions. The \verb|ABSITE.operators| container has 6 operators defined whose names are \verb|{'id', 'f', 'fdag', 'fdag_f', 'n', 'ph'}|. Actually \verb|'fdag_f'| and \verb|'n'| encode equal operators. The phase operator \verb|'ph'| is diagonal, its value is $+1$ for the empty, and $-1$ for the occupied state. The \verb|ABSITE.fermionicities| are $-1$ for \verb|'f'| and \verb|'fdag'| operators, while $+1$ for the others.


\subsection{The ABMPS structures}
The \verb|AB_MPS| structures are used to store Abelian matrix product states. This Abelian structure is able to store both left-canonical, right-canonical, and mixed-canonical matrix product states. The \verb|ABMPS.cut_position| value stores the position of the cut. Matrices for \verb|pos <= ABMPS.cut_position| are left canonical, while for \verb|pos > ABMPS.cut_position|. The left canonical matrices are stored in the \verb|ABMPS.left_matrices| array, while \verb|ABMPS.right_matrices| contains the right canonical matrices. \verb|ABMPS.schmidt| contains the Schmidt-tensor at the cut, while \verb|ABMPS.schmidt_list| contains the Schmidt-tensors for every bond. The latter list is used by ABTEBD routines, that work for fully left canonical MPS.

The MPS matrices (both left and right canonical ones) have three legs \verb|{'t_in','tau','t_out'}| and three quantum numbers (representation labels) associated with the three legs. In case of left canonical tensors the \verb|'t_in'| name denotes the leg incoming from left, while the \verb|'t_out'| legs goes out to the right direction. In case of right canonical tensors the incoming leg is in the right, and the outgoing goes to left. The \verb|'tau'| leg is always incoming. The Schmidt-tensor has always two incoming legs, \verb|'t_left'| and \verb|'t_right'|.

\subsection{The simple ABTEBD}
To start ABTEBD simulations an \verb|ABTEBD_env| structure must be prepared. This 'ABTEBD environment' variable contains all the necessary information about our ABTEBD simulation: the \verb|ABTEBD_env.StateMPS| wavefunction, the array of symmetry structures (\verb|ABTEBD_env.Symmetries|), some basic information (chain length, number of symmetries, fermions (true or false)). The \verb|ABTEBD_env.infinite| logical variable is true if the infinite chain TEBD algorithm is used\cite{Vidal_2007}, and false if we treat a finite chain. The nearest neighbor (2-site) Hamiltonians are collected in the \verb|ABTEBD_env.TwoSiteHlist| array. These NAtensors have always four legs: \verb|{'tau_1', 'tau_2', 'tau_1~', 'tau_2~'}|, where the first two legs are contracted with the \verb|'tau'| legs of the MPS. The exponentialized two site evolvers are collected in the  \verb|ABTEBD_env.Ulist| and \verb|ABTEBD_env.Uhalflist|, the latter containes the evolvers for $\Delta t / 2$, and is used by the 2nd order Trotter evolver. The time step $\Delta t$ is a parameter of the function that creates the \verb|ABTEBD_env| variable.

\subsubsection{Example: the U(1) spinless fermion ABTEBD}
A good starting example for Abelian TEBD is again the U(1) spinless fermion model with nearest neighbor interactions. In the \verb|run_scrpits/| folder the \verb|ABTEBD_U1_nearest_neighbor_spinless_fermion| standalone script simulates the real time dynamics of the model 
\begin{equation}
 \hat{H} = \sum_i \left( - c^\dagger_i c_{i+1} - c^\dagger_{i+1} c_i + V n_i n_{i+1}   \right)
\end{equation}
starting from a charge density wave state $|...010101...\rangle$.
In the script first we define the parameters of the model and the simulation, then the $U(1)$ symmetry is defined. As we want to use the infinite lattice algorithm, it is essential to define the site charges in a way, that the total charge remains zero. Therefore \verb|Q_EMPTY = -1| and \verb|Q_OCCUPIED = +1| is used. After fixing these values, the initial MPS state is set. Equipped with all these variables we can create the \verb|ABTEBD_env| variable using the \verb|MOD_ABTEBD_U1_nearest***_init| function. Below this line the simulation is performed and data is written to the screen. 

If one would like to define an other model, a model initializer function (like \verb|MOD_ABTEBD_U1_nearest***_init|) must be prepared. Once the \verb|ABTEBD_env.StateMPS| and the \verb|ABTEBD_env.Ulist| is set, the TEBD simulation is ready to run.


\section{Non-Abelian MPS and TEBD}
\subsection{Non-Abelian SITE structures}
\subsection{Non-Abelian MPS}
\subsection{Non-Abelian TEBD}




\begin{thebibliography}{99}
\bibitem{GPLv3} GPLv3
\bibitem{NATEBD_paper} NATEBD paper
\bibitem{MikiPhD}
\bibitem{Vidal_2004} Vidal 2004
\bibitem{Vidal_2007} Vidal 2007
\bibitem{Schollwöck 2011} Schollwöck 2011 
\end{thebibliography}

\end{document}
